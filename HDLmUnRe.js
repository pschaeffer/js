/**
 * Class for handling undo and redo processing. 
 *
 * This code provides an extensive undo and redo capability. Undo 
 * allows changes to be removed. Redo allows changes to be restored.
 * Changes are kept in a list (an array actually) so that they can be 
 * removed in reverse order (if need be) and possibly restored in the
 * original order that they were made. A few notes.
 * 
 *   1. Undo is typically invoked using Ctrl + Z. Of course, any other
 *      key or key combination could be used. For now, the standard
 *      Ctrl + Z combination will be used. 
 *      
 *   2. Redo is typically invoked using Ctrl + Y. Of course, any other
 *      key or key combination could be used. For now, the standard
 *      Ctrl + Y combination will be used.
 *      
 *   3. This code maintains an array of changes that are subject to 
 *      undo and redo. The array is in the same order that the changes
 *      were made.
 *      
 *   4. The changes array is of a fixed maximum size. Once the maximum
 *      size is reached (if it is reached), the oldest change will be 
 *      discarded as each new change is added.
 *      
 *   5. The changes array starts out empty. The first entry is added to
 *      the changes array when the first change is made.
 *      
 *   6. Each entry in the changes array contains all of the information 
 *      needed to undo and/or redo the change. Of course, a change is only 
 *      subject to redo processing after undo processing is complete. 
 *      
 *   7. An index variable is always maintained for the changes array. The 
 *      index variable is a simple integer, that is used as an array (the
 *      changes array) subscript. At the beginning of processing (when the 
 *      changes array is empty), the index will be set to minus one. The 
 *      index variable normally identifies the last change added to the 
 *      undo/redo changes array. 
 *      
 *   8. Note that if undo/redo processing is underway, then the index variable
 *      may not point to the last change added to the undo/redo array. For 
 *      example, let us assume 70 changes have been added to the undo/redo 
 *      array. Before any undo/redo processing, the index variable will be 
 *      set to 69 (the last change completed and added to the changes array).
 *      After just one undo, the changes array will still contain 70 entries.
 *      However, the index will be set to 68. If all 70 changes are removed, 
 *      then the changes array will still contain 70 entries. However, the 
 *      index will be set to minus one. Note that at this point all 70 changes
 *      could be restored. If all 70 changes were restored, the index would be
 *      set to 69.
 *      
 *   9. Assume that 70 changes have been added to the changes array and the 
 *      index is set to 69. Then assume that the last four changes are removed
 *      using undo processing. The changes array will still contain 70 entries
 *      and the index will be set to 65. However, at this point the user makes 
 *      a new change (rather than invoking redo). This will cause the last four
 *      changes to be discarded and the new change to be added to the end of 
 *      the changes array. The final index value will be set to 66 and the 
 *      changes array will contain 67 entries.
 *      
 *  10. Many types of changes can be undone and redone. They include expanding 
 *      a list of nodes, collapsing a list of nodes, changing the current node,
 *      renaming a node (at any level), copy, cut, paste, any of the right-click
 *      actions, any keyboard operation, changing any field, drag-and-drop, etc. 
 * 
 * HDLmUnRe short summary.
 *
 * HDLmUnRe description. 
 *
 * @version 1.0
 * @author Peter
 */
"use strict";
/* The HDLmUnRe class doesn't actually do anything. However, it does
   contain code for handling undo and redo processing. The HDLmUnRe 
   class also has a set of global values that are used to manage 
   undo / redo processing. */
class HDLmUnRe {
  /* The method below adds an activate event to the changes array. This 
     code constructs an undo / redo event (for an activate) and then adds
     it to the changes array using a common routine. */
  static addActivate(event, data, HDLmDataNodePath) {
    /* Write a debugging message to the console, if need be */
    if (HDLmGlobals.activeDebugging.showInfo) {
      /* 
      let changesLength = HDLmUnRe.changesArray.length;
      let changesIndex = HDLmUnRe.changesIndex;
      let ignoreValue = HDLmUnRe.changesIgnoreActivate;
      let errorText = `Add Activate - Changes Length (${changesLength}) Changes Index (${changesIndex}) Ignore (${ignoreValue})`;
      console.log(errorText); 
      */
    }
    /* Just exit if the ignore value is set. The ignore value is set
       to prevent events generated by undo / redo processing from 
       being added to the changes array. */
    /* 
    if (HDLmGlobals.activeDebugging.ignoreChange)
      console.log(`Add Activate - Ignore Activate Value (${HDLmUnRe.changesIgnoreActivate})`); 
    */
    if (HDLmUnRe.changesIgnoreActivate > 0) {
      HDLmUnRe.changesIgnoreActivate--;
      return;
    }
    let newChange = new HDLmUnReChange(HDLmUnReTypes.activate);
    newChange.newPath = HDLmDataNodePath.slice(0, HDLmDataNodePath.length); 
    if (HDLmUnRe.changesLastActiveNodePath != null)
      newChange.oldPath = HDLmUnRe.changesLastActiveNodePath.slice();
    HDLmUnRe.addChange(newChange);
  }
  /* The method below adds a change to the changes array. We really 
     need to consider three cases. First, the changes array amy be 
     empty. Second, the changes array may be full. Third, we may be
     in the middle of undo/redo processing. Note that this method
     can never fail and never returns a value. */
  static addChange(newChange) {
    /* console.log('In HDLmUnRe.addChange'); */
    /* console.log('newChange: ', newChange); */
    /* Check if the changes array is empty or not entirely full. 
       Also check if the changes index points to the last change
       added (if any) to the changes array. This will be true at 
       the start of processing and later until the changes array 
       is full. Add a copy of the new change to the changes array 
       and bump the changes index by one. This is not an error 
       condition. */
    let changesIndex = HDLmUnRe.changesIndex;
    let changesLength = HDLmUnRe.changesArray.length;
    let changesMax = HDLmDefines.getNumber('HDLMMAXCHANGES');
    /* console.log('changesIndex: ', changesIndex); */
    /* console.log('changesLength: ', changesLength); */
    /* console.log('changesMax: ', changesMax); */
    if (changesLength < changesMax &&
      changesIndex + 1 == changesLength) {
      changesIndex++;
      HDLmUnRe.changesIndex++;
      let changeCopy = Object.assign({}, newChange);
      HDLmUnRe.changesArray.push(changeCopy);
      if (HDLmGlobals.activeDebugging.showStatus)
        HDLmUnRe.showStatus();
      return;
    }
    /* Check if the changes array is full and the changes array
       index points to the last change added to the changes array.
       Add the new change to the end of the changes array and remove
       the oldest changes array entry. This is also not an error 
       condition. */
    if (changesLength == changesMax &&
        changesIndex + 1 == changesLength) {
      HDLmUnRe.changesArray.shift();
      let changeCopy = Object.assign({}, newChange);
      HDLmUnRe.changesArray.push(changeCopy);
      if (HDLmGlobals.activeDebugging.showStatus)
        HDLmUnRe.showStatus();
      return;
    }
    /* It looks like we are in the middle of undo/redo processing. We 
       want to discard a set of changes array entries and add the new
       one. */
    if (changesIndex + 1 >= changesLength) {
      let errorText = `Invalid changes index value (${changesIndex}) versus changes length (${changesLength})`;
      HDLmAssert(false, errorText);
    }
    /* Write a debugging message to the console, if need be */
    if (HDLmGlobals.activeDebugging.showInfo) {
      /*
      let changesLength = HDLmUnRe.changesArray.length;
      let changesIndex = HDLmUnRe.changesIndex;
      let errorText = `Reset changes array - Old Length (${changesLength}) New Index (${changesIndex})`;
      console.log(errorText); 
      */
    }
    /* Discard a set of changes array entries. This step will have the 
       effect of removing all of the changes array entries that have 
       already been processed using undo. */
    HDLmUnRe.changesArray = HDLmUnRe.changesArray.slice(0, changesIndex + 1);
    changesIndex++;
    HDLmUnRe.changesIndex++;
    let changeCopy = Object.assign({}, newChange);
    HDLmUnRe.changesArray.push(changeCopy)
    if (HDLmGlobals.activeDebugging.showStatus)
      HDLmUnRe.showStatus();
    return;
  }
  /* The method below adds an check event to the changes array. This 
     code constructs an undo / redo event (for a check) and then adds
     it to the changes array using a common routine. A check event
     occurs when a modification node that was disabled, is enabled 
     or when a modification node that was enabled, is disabled. 
     
     Note that this event type is not in use at this time. It turns
     output that using the context menus to change the enablement
     status of a modification causes a very conventional keyboard
     operation to be simulated. The keyboard operation can be undone
     and redone as need be. */
  static addCheck(event, data, HDLmDataNodePath, isChecked) {
    /* Write a debugging message to the console, if need be */
    if (HDLmGlobals.activeDebugging.showInfo) {
      /*
      let changesLength = HDLmUnRe.changesArray.length;
      let changesIndex = HDLmUnRe.changesIndex;
      let ignoreValue = HDLmUnRe.changesIgnoreCheck;
      let errorText = `Add Check - Changes Length (${changesLength}) Changes Index (${changesIndex}) Ignore (${ignoreValue})`;
      console.log(errorText); 
      */
    }
    /* Just exit if the ignore value is set. The ignore value is set
       to prevent events generated by undo / redo processing from 
       being added to the changes array. */
    /*
    if (HDLmGlobals.activeDebugging.ignoreChange)
      console.log(`Add Check - Ignore Check Value (${HDLmUnRe.changesIgnoreCheck})`); 
    */
    if (HDLmUnRe.changesIgnoreCheck > 0) {
      HDLmUnRe.changesIgnoreCheck--;
      return;
    }
    let newChange = new HDLmUnReChange(HDLmUnReTypes.check);
    newChange.nodePath = HDLmDataNodePath.slice(0, HDLmDataNodePath.length);
    newChange.isChecked = isChecked;
    HDLmUnRe.addChange(newChange);
  }
  /* The method below adds an collapse event to the changes array. This 
     code constructs an undo / redo event (for a collapse) and then adds
     it to the changes array using a common routine. */
  static addCollapse(event, data, HDLmDataNodePath) {
    /* Write a debugging message to the console, if need be */
    if (HDLmGlobals.activeDebugging.showInfo) {
      /* 
      let changesLength = HDLmUnRe.changesArray.length;
      let changesIndex = HDLmUnRe.changesIndex;
      let ignoreValue = HDLmUnRe.changesIgnoreCollapse;
      let errorText = `Add Collapse - Changes Length (${changesLength}) Changes Index (${changesIndex}) Ignore (${ignoreValue})`;
      console.log(errorText); 
      */
    }
    /* Just exit if the ignore value is set. The ignore value is set
       to prevent events generated by undo / redo processing from 
       being added to the changes array. */
    /* 
    if (HDLmGlobals.activeDebugging.ignoreChange)
      console.log(`Add Collapse - Ignore Collapse Value (${HDLmUnRe.changesIgnoreCollapse})`); 
    */
    if (HDLmUnRe.changesIgnoreCollapse > 0) {
      HDLmUnRe.changesIgnoreCollapse--;
      return;
    }
    let newChange = new HDLmUnReChange(HDLmUnReTypes.collapse);
    newChange.nodePath = HDLmDataNodePath.slice(0, HDLmDataNodePath.length);
    HDLmUnRe.addChange(newChange);
  }
  /* The method below adds a copy event to the changes array. This 
     code constructs an undo / redo event (for a copy) and then adds
     it to the changes array using a common routine. */
  static addCopy(event, data, oldCopyValue, newCopyValue) {
    /* Write a debugging message to the console, if need be */
    if (HDLmGlobals.activeDebugging.showInfo) {
      /*
      let changesLength = HDLmUnRe.changesArray.length;
      let changesIndex = HDLmUnRe.changesIndex;
      let ignoreValue = HDLmUnRe.changesIgnoreCopy;
      let errorText = `Add Copy - Changes Length (${changesLength}) Changes Index (${changesIndex}) Ignore (${ignoreValue})`;
      console.log(errorText); 
      */
    }
    /* Just exit if the ignore value is set. The ignore value is set
       to prevent events generated by undo / redo processing from 
       being added to the changes array. */
    /* 
    if (HDLmGlobals.activeDebugging.ignoreChange)
      console.log(`Add Copy - Ignore Copy Value (${HDLmUnRe.changesIgnoreCopy})`); 
    */
    if (HDLmUnRe.changesIgnoreCopy > 0) {
      HDLmUnRe.changesIgnoreCopy--;
      return;
    }
    let newChange = new HDLmUnReChange(HDLmUnReTypes.copy);
    newChange.oldCopyValue = oldCopyValue;
    newChange.newCopyValue = newCopyValue;
    HDLmUnRe.addChange(newChange);
  }
  /* The method below adds a cut (ctrl-x) event to the changes array.
     This code constructs an undo / redo event (for a cut (ctrl-x)) 
     and then adds it to the changes array using a common routine. 
     The old and new cut values are the old and new copy buffer.
     The cut node path is that node path of the node that wss cut. */
  static addCut(event, data,
                oldCutValue, newCutValue, cutNodePath,
                isActive, isExpanded) {
    /* Write a debugging message to the console, if need be */
    if (HDLmGlobals.activeDebugging.showInfo) {
      /* 
      let changesLength = HDLmUnRe.changesArray.length;
      let changesIndex = HDLmUnRe.changesIndex;
      let ignoreValue = HDLmUnRe.changesIgnoreCut;
      let errorText = `Add Cut - Changes Length (${changesLength}) Changes Index (${changesIndex}) Ignore (${ignoreValue})`;
      console.log(errorText); 
      */
    }
    /* Just exit if the ignore value is set. The ignore value is set
       to prevent events generated by undo / redo processing from 
       being added to the changes array. */
    /* 
    if (HDLmGlobals.activeDebugging.ignoreChange)
      console.log(`Add Cut - Ignore Cut Value (${HDLmUnRe.changesIgnoreCut})`); 
    */
    if (HDLmUnRe.changesIgnoreCut > 0) {
      HDLmUnRe.changesIgnoreCut--;
      return;
    }
    /* Actually doing the cut will cause a deactivation event for the node that
       is cut. Of course, we don't want add a deactivation event to the undo / redo 
       changes array. */
    /* 
    if (HDLmGlobals.activeDebugging.ignoreChange)
      console.log(`Add Cut - Ignore Deactivate Value (${HDLmUnRe.changesIgnoreDeactivate})`); 
    */
    HDLmUnRe.changesIgnoreDeactivate++;
    /* Build the new change */
    let newChange = new HDLmUnReChange(HDLmUnReTypes.cut);
    newChange.oldPath = cutNodePath.slice();
    newChange.oldCopyValue = oldCutValue;
    newChange.newCopyValue = newCutValue;
    newChange.isActive = isActive;
    newChange.isExpanded = isExpanded;
    HDLmUnRe.addChange(newChange);
  }
  /* The method below does not add a deactivate event to the changes array.
     This code is only used to keep track of the node that is being deactivated.
     We need to know the identify (path) of the last node that was deactivated 
     for activation undo / redo processing. */
  static addDeactivate(event, data, HDLmDataNodePath) {
    /* Write a debugging message to the console, if need be */
    if (HDLmGlobals.activeDebugging.showInfo) {
      /* 
      let changesLength = HDLmUnRe.changesArray.length;
      let changesIndex = HDLmUnRe.changesIndex;
      let ignoreValue = HDLmUnRe.changesIgnoreDeactivate;
      let errorText = `Add Deactivate - Changes Length (${changesLength}) Changes Index (${changesIndex}) Ignore (${ignoreValue})`;
      console.log(errorText); 
      */
    }
    /* Just exit if the ignore value is set. The ignore value is set
       to prevent events generated by undo / redo processing from 
       being added to the changes array. */
    /* 
    if (HDLmGlobals.activeDebugging.ignoreChange)
      console.log(`Add Deactivate - Ignore Deactivate Value (${HDLmUnRe.changesIgnoreDeactivate})`); 
    */
    if (HDLmUnRe.changesIgnoreDeactivate > 0) {
      HDLmUnRe.changesIgnoreDeactivate--;
      return;H
    }
    HDLmUnRe.changesLastActiveNodePath = HDLmDataNodePath.slice(0, HDLmDataNodePath.length);
  }
  /* The method below adds a delete event to the changes array. This 
     code constructs an undo / redo event (for a delete) and then adds
     it to the changes array using a common routine. A delete event
     occurs when a delete menu entry is successfully invoked. */
  static addDelete(event, data, deleteNodePath, deleteTreeData,
                   isActive, isExpanded) {
    /* Write a debugging message to the console, if need be */
    if (HDLmGlobals.activeDebugging.showInfo) {
      /* 
      let changesLength = HDLmUnRe.changesArray.length;
      let changesIndex = HDLmUnRe.changesIndex;
      let ignoreValue = HDLmUnRe.changesIgnoreDelete;
      let errorText = `Add Delete - Changes Length (${changesLength}) Changes Index (${changesIndex}) Ignore (${ignoreValue})`;
      console.log(errorText); 
      */
    }
    /* Just exit if the ignore value is set. The ignore value is set
       to prevent events generated by undo / redo processing from 
       being added to the changes array. */
    /* 
    if (HDLmGlobals.activeDebugging.ignoreChange)
      console.log(`Add Delete - Ignore Delete Value (${HDLmUnRe.changesIgnoreDelete})`); 
    */
    if (HDLmUnRe.changesIgnoreDelete > 0) {
      HDLmUnRe.changesIgnoreDelete--;
      return;
    }
    let newChange = new HDLmUnReChange(HDLmUnReTypes.delete);
    newChange.oldPath = deleteNodePath.slice();
    newChange.oldCopyValue = deleteTreeData;
    newChange.isActive = isActive;
    newChange.isExpanded = isExpanded;
    HDLmUnRe.addChange(newChange);
  }
  /* The method below adds a DND event to the changes array. This 
     code constructs an undo / redo event (for a DND) and then adds
     it to the changes array using a common routine. A DND event
     occurs when a DND operation is successfully completed. Note
     that a DND event is not successful until it is done. */ 
  static addDnd(event, data, fromNodePath, 
                dndFancyNode, dndNodePath, dndTreeDataStr) {
    /* Write a debugging message to the console, if need be */
    if (HDLmGlobals.activeDebugging.showInfo) {
      /* 
      let changesLength = HDLmUnRe.changesArray.length;
      let changesIndex = HDLmUnRe.changesIndex;
      let ignoreValue = HDLmUnRe.changesIgnoreDnd;
      let errorText = `Add DND - Changes Length (${changesLength}) Changes Index (${changesIndex}) Ignore (${ignoreValue})`;
      console.log(errorText); 
      */
    }
    /* Just exit if the ignore value is set. The ignore value is set
       to prevent events generated by undo / redo processing from 
       being added to the changes array. */
    /* 
    if (HDLmGlobals.activeDebugging.ignoreChange)
      console.log(`Add DND - Ignore DND Value (${HDLmUnRe.changesIgnoreDnd})`); 
    */
    if (HDLmUnRe.changesIgnoreDnd > 0) {
      HDLmUnRe.changesIgnoreDnd--;
      return;
    }
    let newChange = new HDLmUnReChange(HDLmUnReTypes.dnd);
    if (dndFancyNode != null) {
      newChange.isActive = dndFancyNode.isActive();
      newChange.isExpanded = dndFancyNode.isExpanded();
    }
    newChange.newPath = dndNodePath.slice();
    newChange.newCopyValue = dndTreeDataStr;
    newChange.oldPath = fromNodePath.slice();
    HDLmUnRe.addChange(newChange);
  }
  /* The method below adds an edit event to the changes array. This 
     code constructs an undo / redo event (for an edit) and then 
     adds it to the changes array using a common routine. An edit
     event occurs when a node is renamed using the inline edit 
     mechanism provided by Fancytree. */
  static addEdit(oldName, newName, oldNodePath, oldFancyNode) {
    /* Write a debugging message to the console, if need be */
    if (HDLmGlobals.activeDebugging.showInfo) {
      /* 
      let changesLength = HDLmUnRe.changesArray.length;
      let changesIndex = HDLmUnRe.changesIndex;
      let ignoreValue = HDLmUnRe.changesIgnoreEdit;
      let errorText = `Add Edit - Changes Length (${changesLength}) Changes Index (${changesIndex}) Ignore (${ignoreValue})`;
      console.log(errorText); 
      */
    }
    /* Just exit if the ignore value is set. The ignore value is set
       to prevent events generated by undo / redo processing from 
       being added to the changes array. */
    /* 
    if (HDLmGlobals.activeDebugging.ignoreChange)
      console.log(`Add Edit - Ignore Edit Value (${HDLmUnRe.changesIgnoreEdit})`); 
    */
    if (HDLmUnRe.changesIgnoreEdit > 0) {
      HDLmUnRe.changesIgnoreEdit--;
      return;
    }
    let newChange = new HDLmUnReChange(HDLmUnReTypes.edit);
    newChange.oldPath = oldNodePath.slice(0, oldNodePath.length);
    newChange.oldName = oldName;
    newChange.newName = newName;
    newChange.isActive = oldFancyNode.isActive();
    newChange.isExpanded = oldFancyNode.isExpanded();
    HDLmUnRe.addChange(newChange);
  }
  /* The method below adds an expand event to the changes array. This 
     code constructs an undo / redo event (for an expand) and then 
     adds it to the changes array using a common routine. */
  static addExpand(event, data, HDLmDataNodePath) {
    /* Write a debugging message to the console, if need be */
    if (HDLmGlobals.activeDebugging.showInfo) {
      /*
      let changesLength = HDLmUnRe.changesArray.length;
      let changesIndex = HDLmUnRe.changesIndex;
      let ignoreValue = HDLmUnRe.changesIgnoreExpand;
      let nodePath = HDLmDataNodePath.slice();
      let errorText = `Add Expand - Changes Length (${changesLength}) Changes Index (${changesIndex}) Ignore (${ignoreValue}) Path (${nodePath.toString()})`;
      console.log(errorText); 
      */
      /* 
      if (ignoreValue == false)
        console.log(new Error().stack); 
      */
    }
    /* Just exit if the ignore value is set. The ignore value is set
       to prevent events generated by undo / redo processing from 
       being added to the changes array. */
    /* 
    if (HDLmGlobals.activeDebugging.ignoreChange)
      console.log(`Add Expand - Ignore Expand Value (${HDLmUnRe.changesIgnoreExpand})`); 
    */
    if (HDLmUnRe.changesIgnoreExpand > 0) {
      HDLmUnRe.changesIgnoreExpand--;
      return;
    }
    let newChange = new HDLmUnReChange(HDLmUnReTypes.expand);
    newChange.nodePath = HDLmDataNodePath.slice(0, HDLmDataNodePath.length);
    HDLmUnRe.addChange(newChange);
  }
  /* The method below adds an insert event to the changes array. This 
     code constructs an undo / redo event (for an insert) and then adds
     it to the changes array using a common routine. An insert event
     occurs when an insert menu entry is successfully invoked. Note
     that an insert event is not successful until all of the required
     fields have been filled in. */
  static addInsert(event, data, insertNodePath, insertTreeData) {
    /* Write a debugging message to the console, if need be */
    if (HDLmGlobals.activeDebugging.showInfo) {
      /*
      let changesLength = HDLmUnRe.changesArray.length;
      let changesIndex = HDLmUnRe.changesIndex;
      let ignoreValue = HDLmUnRe.changesIgnoreInsert;
      let errorText = `Add Insert - Changes Length (${changesLength}) Changes Index (${changesIndex}) Ignore (${ignoreValue})`;
      console.log(errorText); 
      */
    }
    /* Just exit if the ignore value is set. The ignore value is set
       to prevent events generated by undo / redo processing from 
       being added to the changes array. */
    /* 
    if (HDLmGlobals.activeDebugging.ignoreChange)
      console.log(`Add Insert - Ignore Insert Value (${HDLmUnRe.changesIgnoreInsert})`); 
    */
    if (HDLmUnRe.changesIgnoreInsert > 0) {
      HDLmUnRe.changesIgnoreInsert--;
      return;
    }
    let newChange = new HDLmUnReChange(HDLmUnReTypes.insert);
    newChange.newPath = insertNodePath.slice();
    newChange.newCopyValue = insertTreeData;
    HDLmUnRe.addChange(newChange);
  }
  /* The method below adds a modify event to the changes array. This 
     code constructs an undo / redo event (for a modify) and then 
     adds it to the changes array using a common routine. A modify
     event occurs when a node is changed using the node contents
     editor. Note that a node rename is considered to be an edit 
     event, not a modify event. */ 
  static addModify(nodePath, oldNodeState, newNodeState) {
    /* Check if the defines have been fully initialized. We really can't
       keep track of changes until the defines have been fully initialized. */
    if (!HDLmDefines.isInitialized())
      return;
    /* In one very important case (set of cases), we don't want 
       to keep track of node modifications. A create new node step
       (create new node operation) will cause many node modification 
       events to be genereted as a new node is inserted into the node
       tree. However, we don't want these modification events to be 
       added to the undo / redo changes array. */
    if (HDLmGlobals.activeNodeType != null) 
      return;
    /* Write a debugging message to the console, if need be */
    if (HDLmGlobals.activeDebugging.showInfo) {
      /*
      let changesLength = HDLmUnRe.changesArray.length;
      let changesIndex = HDLmUnRe.changesIndex;
      let ignoreValue = HDLmUnRe.changesIgnoreModify;
      let errorText = `Add Modify - Changes Length (${changesLength}) Changes Index (${changesIndex}) Ignore (${ignoreValue})`;
      console.log(errorText); 
      */
    }
    /* Just exit if the ignore value is set. The ignore value is set
       to prevent events generated by undo / redo processing from 
       being added to the changes array. */
    /* 
    if (HDLmGlobals.activeDebugging.ignoreChange)
      console.log(`Add Modify - Ignore Modify Value (${HDLmUnRe.changesIgnoreModify})`); 
    */
    if (HDLmUnRe.changesIgnoreModify > 0) {
      HDLmUnRe.changesIgnoreModify--;
      return;
    }
    let newChange = new HDLmUnReChange(HDLmUnReTypes.modify);
    newChange.nodePath = nodePath.slice(0, nodePath.length);
    newChange.oldNodeState = oldNodeState;
    newChange.newNodeState = newNodeState;
    HDLmUnRe.addChange(newChange);
  }
  /* The method below adds a paste event to the changes array. This 
     code constructs an undo / redo event (for a paste) and then adds
     it to the changes array using a common routine. A paste event
     occurs when a paste menu entry is invoked after a successful 
     copy. */
  static addPaste(event, data, pasteFancyNode, childNodePath, pasteTreeData) {
    /* Write a debugging message to the console, if need be */
    if (HDLmGlobals.activeDebugging.showInfo) {
      /* 
      let changesLength = HDLmUnRe.changesArray.length;
      let changesIndex = HDLmUnRe.changesIndex;
      let ignoreValue = HDLmUnRe.changesIgnorePaste;
      let errorText = `Add Paste - Changes Length (${changesLength}) Changes Index (${changesIndex}) Ignore (${ignoreValue})`;
      console.log(errorText); 
      */
    }
    /* Just exit if the ignore value is set. The ignore value is set
       to prevent events generated by undo / redo processing from 
       being added to the changes array. */
    /* 
    if (HDLmGlobals.activeDebugging.ignoreChange)
      console.log(`Add Paste - Ignore Paste Value (${HDLmUnRe.changesIgnorePaste})`); 
    */
    if (HDLmUnRe.changesIgnorePaste > 0) {
      HDLmUnRe.changesIgnorePaste--;
      return;
    }
    let newChange = new HDLmUnReChange(HDLmUnReTypes.paste);
    newChange.newPath = childNodePath.slice();
    newChange.newCopyValue = pasteTreeData;
    HDLmUnRe.addChange(newChange);
  }
  /* The next routine activates a node in such a way that the activation
     event is not added to the changes array. This method is needed to 
     handle internal activation events. */
  static noChangeActivate(fancyNode) {
    /* 
    if (HDLmGlobals.activeDebugging.ignoreChange)
      console.log(`No Change Activate - Ignore Activate Value (${HDLmUnRe.changesIgnoreActivate})`); 
    */
    HDLmUnRe.changesIgnoreActivate++;
    fancyNode.setActive(true);
  }
  /* The next routine collapes a node in such a way that the collapse
     event is not added to the changes array. This method is needed
     to handle internal collapse events. */
  static noChangeCollapse(fancyNode) {
    /* 
    if (HDLmGlobals.activeDebugging.ignoreChange)
      console.log(`No Change Collapse - Ignore Collapse Value (${HDLmUnRe.changesIgnoreCollapse})`); 
    */
    HDLmUnRe.changesIgnoreCollapse++;
    fancyNode.setExpanded(false);
  }
  /* The next routine deactivates a node in such a way that the
     deactivation event is not added to the changes array. This
     method is needed to handle internal deactivation events. */
  static noChangeDeactivate(fancyNode) {
    /* 
    if (HDLmGlobals.activeDebugging.ignoreChange)
      console.log(`No Change Deactivate - Ignore Deactivate Value (${HDLmUnRe.changesIgnoreDeactivate})`); 
    */
    HDLmUnRe.changesIgnoreDeactivate++;
    fancyNode.setActive(false);
  }
  /* The next routine expands a node in such a way that the expand
     event is not added to the changes array. This method is needed
     to handle internal expansion events. */
  static noChangeExpand(fancyNode) {
    /* 
    if (HDLmGlobals.activeDebugging.ignoreChange)
      console.log(`No Change Expand - Ignore Expand Value (${HDLmUnRe.changesIgnoreExpand})`); 
    */
    HDLmUnRe.changesIgnoreExpand++;
    fancyNode.setExpanded(true);
  }
  /* The method below redoes a change, if this is possible. The 
     actual work of redoing a change is handled by a separate 
     routine. This method examines the changes array and the changes
     index looking for a change to redo. If no such change is
     found, this routine returns immediately to the caller. If
     a change that can be redone is found, the change index is 
     updated and the separate routine is invoked to redo the change. */
  static redoChange(fancyNode, currentTreeNode, currentTreeType, source) {
    /* console.log('In HDLmUnRe.redoChange'); */
    let changesIndex = HDLmUnRe.changesIndex;
    let changesLength = HDLmUnRe.changesArray.length;
    /* console.log('changesIndex: ', changesIndex); */
    /* console.log('changesLength: ', changesLength); */
    /* Check for, and report, a serious error */
    if (changesIndex + 1 > changesLength) {
      let errorText = `Invalid changes index value (${changesIndex}) versus changes length (${changesLength})`;
      HDLmAssert(false, errorText);
    }
    /* If the changes index points to the last entry in the changes array
       then, we have we have no more changes to redo. Just return to the
       caller. */
    if (changesIndex + 1 == changesLength)
      return;
    /* Get the change that can be redone and update the change index */
    let currentChange = HDLmUnRe.changesArray[changesIndex + 1];
    /* console.log('currentChange: ', currentChange); */
    /* Check if the current redo of a change should just be ignored.
       We want to ignore a redo of a change if the change came from
       the 'wrong' event source and if the change is an activation
       or DND.*/
    if (source != 'Fancytree on') {
      if (currentChange.changeType == HDLmUnReTypes.activate ||
          currentChange.changeType == HDLmUnReTypes.dnd)
        return;
      if (HDLmGlobals.activeEditorType == HDLmEditorTypes.popup &&
          (currentChange.changeType == HDLmUnReTypes.collapse ||
           currentChange.changeType == HDLmUnReTypes.expand))
        return;
    }
    changesIndex++;
    HDLmUnRe.changesIndex++;
    if (HDLmGlobals.activeDebugging.showStatus)
      HDLmUnRe.showStatus();
    HDLmUnRe.redoExecute(currentChange, source);
  }
  /* This routine does the actual work of redoing a change. The caller
     passes a change object. This routine examines the change object 
     and does all of the work needed to redo the change. */
  static redoExecute(currentChange, source) {
    /* console.log('In HDLmUnRe.redoExecute'); */
    /* console.log('currentChange: ', currentChange); */
    let type = currentChange.changeType;
    let fancyTreeNode;
    switch (type) {
      /* Redo an activation event */
      case HDLmUnReTypes.activate: {
        /* Try to locate the Fancytree node */
        fancyTreeNode = HDLmTree.locateFancyNode(currentChange.newPath);
        /* Report an error if the Fancytree node could not be found */
        if (fancyTreeNode == null) {
          let nodeString = currentChange.newPath.toString();
          HDLmError.buildError('Error', 'Locate', 25, nodeString);
          return;
        }
        /* We have some work to do, if we located the Fancytree node */
        if (fancyTreeNode != null) {
          /* Check if some other node was previously active. If this is 
             true, then activating the current node will cause a deactivation
             event. This event must be ignored. */
          if (currentChange.oldPath != null) {
            /* 
            if (HDLmGlobals.activeDebugging.ignoreChange)
              console.log(`Redo Execute Activate - Ignore Deactivate Value (${HDLmUnRe.changesIgnoreDeactivate})`); 
            */
            HDLmUnRe.changesIgnoreDeactivation++;
          }
          HDLmUnRe.noChangeActivate(fancyTreeNode);
        }
        break;
      }
      /* Redo a collapse event */
      case HDLmUnReTypes.collapse: {
        /* Try to locate the Fancytree node */
        fancyTreeNode = HDLmTree.locateFancyNode(currentChange.nodePath);
        /* Report an error if the Fancytree node could not be found */
        if (fancyTreeNode == null) {
          let nodeString = currentChange.nodePath.toString();
          HDLmError.buildError('Error', 'Locate', 25, nodeString);
          return;
        }
        /* Just exit if we did not find the Fancytree node */
        if (fancyTreeNode == null)
          break;
        HDLmUnRe.noChangeCollapse(fancyTreeNode);
        break;
      }
      /* Redo a copy event */
      case HDLmUnReTypes.copy: {
        HDLmGlobals.activeCopyBuffer = currentChange.newCopyValue;
        break;
      }
      /* Redo a cut (ctrl-x) event */
      case HDLmUnReTypes.cut: {
        HDLmGlobals.activeCopyBuffer = currentChange.newCopyValue;
        /* Get the path to the child node that must be deleted */
        let childNodePath = currentChange.oldPath.slice();
        /* Try to locate the child Fancytree node */
        let childFancytreeNode = HDLmTree.locateFancyNode(childNodePath);
        /* Report an error if the Fancytree node could not be found */
        if (childFancytreeNode == null) {
          let nodeString = childNodePath.toString();
          HDLmError.buildError('Error', 'Locate', 25, nodeString);
          return;
        }
        /* Try to locate the child tree node using the child node path */
        let childTreeNode = HDLmTree.locateTreeNode(childNodePath);
        /* Report an error if the node could not be found */
        if (childTreeNode == null) {
          let nodeString = childNodePath.toString();
          console.log('In HDLmunRe.redoExecute', nodeString);
          HDLmError.buildError('Error', 'Locate', 9, nodeString);
          return;
        }
        /* Invoke a standard routine to do all of the actual work of deleting 
           the tree node and the Fancytree node */
        HDLmTree.deleteTreeNode(childFancytreeNode, childTreeNode);
        break;
      }
      /* Redo a delete event */
      case HDLmUnReTypes.delete: {
        /* Get the path to the child node that must be deleted */
        let childNodePath = currentChange.oldPath.slice();
        /* Try to locate the child Fancytree node */
        let childFancytreeNode = HDLmTree.locateFancyNode(childNodePath);
        /* Report an error if the Fancytree node could not be found */
        if (childFancytreeNode == null) {
          let nodeString = childNodePath.toString();
          HDLmError.buildError('Error', 'Locate', 25, nodeString);
          return;
        }
        /* Try to locate the child tree node using the child node path */
        let childTreeNode = HDLmTree.locateTreeNode(childNodePath);
        /* Report an error if the node could not be found */
        if (childTreeNode == null) {
          let nodeString = childNodePath.toString();
          console.log('In HDLmunRe.redoExecute', nodeString);
          HDLmError.buildError('Error', 'Locate', 9, nodeString);
          return;
        }
        /* Invoke a standard routine to do all of the actual work of deleting 
           the tree node and the Fancytree node */
        HDLmTree.deleteTreeNode(childFancytreeNode, childTreeNode);
        break;
      }
      /* Redo a DND event */
      case HDLmUnReTypes.dnd: {
        let isActive = currentChange.isActive;
        let isExpanded = currentChange.isExpanded;
        /* Get the parent Fancytree node path and the DND data. Note that
           the path stored in the undo / redo change event is of the node
           added using DND, not the parent of the added node. */
        let dndTreeNode = JSON.parse(currentChange.newCopyValue);
        let dndNodePath = currentChange.newPath.slice();
        /* We need to modify all of the tree node paths so that they contain
           the correct values for where the data is being moved to */
        HDLmTree.modifyTreeNodePath(dndNodePath, dndTreeNode);
        /* Try to locate the parent Fancytree node */
        let reportFancyLocateErrors = true;
        let parentFancytreeNode = HDLmTree.locateFancyParentNode(dndNodePath, reportFancyLocateErrors);
        /* Report an error if the Fancytree node could not be found */
        if (parentFancytreeNode == null) {
          let nodeString = parentFancyPath.toString();
          HDLmError.buildError('Error', 'Locate', 25, nodeString);
          return;
        }
        /* Locate the from Fancytree node and the from node. Both must be 
           deleted here. */
        let oldFromNodePath = currentChange.oldPath.slice();
        /* Try to locate the Fancytree node using the old node path */
        let oldFromFancytreeNode = HDLmTree.locateFancyNode(oldFromNodePath);
        /* Report an error if the Fancytree node could not be found */
        if (oldFromFancytreeNode == null) {
          let nodeString = oldFromNodePath.toString();
          HDLmError.buildError('Error', 'Locate', 25, nodeString);
          return;
        }
        /* Try to locate the from tree node using the old node path */
        let fromTreeNode = HDLmTree.locateTreeNode(oldFromNodePath);
        /* Report an error if the node could not be found */
        if (fromTreeNode == null) {
          let nodeString = oldFromNodePath.toString();
          console.log('In HDLmunRe.redoExecute', nodeString);
          HDLmError.buildError('Error', 'Locate', 9, nodeString);
          return;
        }
        /* Delete the node we are dragging from. Note that both the tree node and
           the Fancytree node are deleted. Note that tree node, may actually have
           nodes under it. Of course, this also applies to the Fancytree node. 
           However, the Fancytree code should take care of this. */
        HDLmTree.deleteTreeNode(oldFromFancytreeNode, fromTreeNode);
        let handlingCmdInsertFalse = false;
        let processSubNodesTrue = true;
        let updateDatabase = true;
        let usePendingInsertsTrue = true;
        HDLmMenus.insertIntoBothTrees(parentFancytreeNode, dndTreeNode, 
                                      usePendingInsertsTrue, processSubNodesTrue, updateDatabase,
                                      handlingCmdInsertFalse);
        HDLmTree.processPendingInserts();
        HDLmUnRe.resetNode(parentFancytreeNode, isActive, isExpanded);
        break;
      }
      /* Redo an edit event */
      case HDLmUnReTypes.edit: {
        /* Get the old node name and the new node name. At this point
           the node will actually have the old node name. */
        let oldName = currentChange.oldName;
        let newName = currentChange.newName;
        let oldPath = currentChange.oldPath.slice();
        /* Build the path for the current node. The path for the node
           must use the new node name. */
        let newPath = oldPath.slice(0, oldPath.length - 1);
        newPath.push(newName);
        let isActive = currentChange.isActive;
        let isExpanded = currentChange.isExpanded;
        /* Try to locate the tree node using the old node path */
        let targetTreeNode = HDLmTree.locateTreeNode(oldPath);
        /* Report an error if the node could not be found */
        if (targetTreeNode == null) {
          let nodeString = oldPath.toString();
          console.log('In HDLmunRe.redoExecute', nodeString);
          HDLmError.buildError('Error', 'Locate', 9, nodeString);
          return;
        }
        /* Just exit if we did not find the tree node */
        if (targetTreeNode == null)
          break;
        /* Try to locate the Fancytree node using the old node path */
        fancyTreeNode = HDLmTree.locateFancyNode(oldPath);
        /* Report an error if the Fancytree node could not be found */
        if (fancyTreeNode == null) {
          let nodeString = oldPath.toString();
          HDLmError.buildError('Error', 'Locate', 25, nodeString);
          return;
        }
        /* Just exit if we did not find the Fancytree node */
        if (fancyTreeNode == null)
          break;
        /* Create a new Fancytree node by redoing the current change */
        let removeOldFancyTrue = true;
        let newFancyNode = HDLmTree.modifyNodeName(newName, fancyTreeNode, targetTreeNode, removeOldFancyTrue);
        HDLmUnRe.resetNode(newFancyNode, isActive, isExpanded);
        HDLmTree.updateRelatedOperations(newPath);
        break
      }
      /* Redo an expand event */
      case HDLmUnReTypes.expand: {
        /* Try to locate the Fancytree node */
        fancyTreeNode = HDLmTree.locateFancyNode(currentChange.nodePath);
        /* Report an error if the Fancytree node could not be found */
        if (fancyTreeNode == null) {
          let nodeString = currentChange.nodePath.toString();
          HDLmError.buildError('Error', 'Locate', 25, nodeString);
          return;
        }
        /* Just exit if we did not find the Fancytree node */
        if (fancyTreeNode == null)
          break;
        HDLmUnRe.noChangeExpand(fancyTreeNode);
        break;
      }
      /* Redo an insert event */
      case HDLmUnReTypes.insert: {
        /* Get the insert Fancytree node path and the insert data. Note that
           the path stored in the undo / redo change event is of the inserted
           node, not the parent of the insert node. */
        let insertTreeNode = JSON.parse(currentChange.newCopyValue);
        let insertNodePath = insertTreeNode.nodePath.slice();
        /* Try to locate the parent Fancytree node */
        let reportFancyLocateErrors = true;
        let parentFancytreeNode = HDLmTree.locateFancyParentNode(insertNodePath, reportFancyLocateErrors);
        /* Report an error if the Fancytree node could not be found */
        if (parentFancytreeNode == null) {
          let nodeString = parentFancyPath.toString();
          HDLmError.buildError('Error', 'Locate', 25, nodeString);
          return;
        }
        let handlingCmdInsertFalse = false;
        let processSubNodesTrue = true;
        let updateDatabase = true;
        let usePendingInsertsTrue = true;
        HDLmMenus.insertIntoBothTrees(parentFancytreeNode, insertTreeNode, 
                                      usePendingInsertsTrue, processSubNodesTrue, updateDatabase,
                                      handlingCmdInsertFalse);
        HDLmTree.processPendingInserts();
        break;
      }
      /* Redo a node modify event */
      case HDLmUnReTypes.modify: {
        /* Get the new node state and the node path */
        let newNodeState = currentChange.newNodeState;
        let nodePath = currentChange.nodePath.slice();
        /* Try to locate the tree node using the node path */
        let targetTreeNode = HDLmTree.locateTreeNode(nodePath);
        /* Report an error if the tree node could not be found */
        if (targetTreeNode == null) {
          let nodeString = nodePath.toString();
          console.log('In HDLmunRe.redoExecute', nodeString);
          HDLmError.buildError('Error', 'Locate', 9, nodeString);
          return;
        }
        /* Use the new node state to reset the node */
        /* 
        if (HDLmGlobals.activeDebugging.ignoreChange)
          console.log(`Redo Execute Modify - Ignore Modify Value (${HDLmUnRe.changesIgnoreModify})`); 
        */
        HDLmUnRe.changesIgnoreModify++;
        targetTreeNode.details = JSON.parse(newNodeState);
        let divDescriptions = HDLmDefines.getString('HDLMENTRYDESCRIPTIONS');
        let divValues = HDLmDefines.getString('HDLMENTRYVALUES');
        let callSource = 'HDLmUnRe.redoExecute';
        let currentDomElementNull = null;
        let handlingCmdInsertFalse = false;
        let inlineStartupFlagFalse = false;
        let newTreeEntryTrue = true;
        let possibleRuleTypesNull = null;
        HDLmMod.displayMod(divDescriptions, divValues, targetTreeNode,
                           possibleRuleTypesNull, currentDomElementNull,
                           HDLmGlobals.activeEditorType, newTreeEntryTrue,
                           inlineStartupFlagFalse, handlingCmdInsertFalse,
                           callSource);
        HDLmTree.updateRelatedOperations(nodePath);
        break;
      }
      /* Redo a paste event */
      case HDLmUnReTypes.paste: {
        /* Get the paste Fancytree node path and the paste data. Note that
           the path stored in the undo / redo change event is of the pasted
           node, not the parent of the pasted node. */
        let pasteTreeNode  = JSON.parse(currentChange.newCopyValue);
        let pasteNodePath = pasteTreeNode.nodePath.slice();
        /* Try to locate the parent Fancytree node */
        let reportFancyLocateErrors = true;
        let parentFancytreeNode = HDLmTree.locateFancyParentNode(pasteNodePath, reportFancyLocateErrors);
        /* Report an error if the Fancytree node could not be found */
        if (parentFancytreeNode == null) {
          let nodeString = parentFancyPath.toString();
          HDLmError.buildError('Error', 'Locate', 25, nodeString);
          return;
        }
        let handlingCmdInsertFalse = false;
        let processSubNodesTrue = true;
        let updateDatabase = true;
        let usePendingInsertsTrue = true;
        HDLmMenus.insertIntoBothTrees(parentFancytreeNode, pasteTreeNode, 
                                      usePendingInsertsTrue, processSubNodesTrue, updateDatabase,
                                      handlingCmdInsertFalse);
        HDLmTree.processPendingInserts();
        break;
      }
      /* Report an error if the undo / redo change type did not match one 
         of the expected choices */
      default: {
        let errorString = type;
        HDLmError.buildError('Error', 'Invalid type', 24, errorString);
        break;
      }
    }
  }
  /* This routine resets the status of a Fancytree node if need be.
     The caller passes the Fancytree node and the desired final 
     activation and expanded status. This routine checks the actual 
     activation status against the desired final activation status
     and changes if the activation status if need be. This routine 
     checks the actual expanded status against the desired final
     expanded status and changes if the expanded status if need be.*/
  static resetNode(fancyNode, finalActive, finalExpanded) {
    /* Check if the Fancytree node is active and expanded. These values
       are used later to set the final status of the Fancytree node. */
    let fancyNodeActive = fancyNode.isActive();
    let fancyNodeExpanded = fancyNode.isExpanded();
    /* Check if the Fancynode activation state needs to be changed */
    if (fancyNodeActive != finalActive) {
      if (finalActive)
        HDLmUnRe.noChangeActivate(fancyNode);
      else 
        HDLmUnRe.noChangeDeactivate(fancyNode);
    }
    /* Check if the Fancynode expand/collapse state needs to be changed */
    if (fancyNodeExpanded != finalExpanded) {
      if (finalExpanded)
        HDLmUnRe.noChangeExpand(fancyNode);
      else
        HDLmUnRe.noChangeCollapse(fancyNode);
    }
  }
  /* This routine shows the current changes array index and length 
     in the error text area */
  static showStatus() {
    let changesIndex = HDLmUnRe.changesIndex;
    let changesLength = HDLmUnRe.changesArray.length;
    let errorText = `Index ${changesIndex} Length ${changesLength}`;
    HDLmUtility.setErrorText(errorText);
  }
  /* The method below undoes a change, if this is possible. The 
     actual work of undoing a change is handled by a separate 
     routine. This method examines the changes array and the changes
     index looking for a change to undo. If no such change is
     found, this routine returns immediately to the caller. If
     a change that can be undone is found, the change index is 
     updated and the separate routine is invoked to undo the change. */
  static undoChange(fancyNode, currentTreeNode, currentTreeType, source) {
    /* console.log('In HDLmUnRe.undoChange'); */
    /* console.log('source: ', source); */
    let changesIndex = HDLmUnRe.changesIndex;
    let changesLength = HDLmUnRe.changesArray.length;
    /* console.log('changesIndex: ', changesIndex); */
    /* console.log('changesLength: ', changesLength); */
    /* Check for, and report, a serious error */
    if (changesIndex + 1 > changesLength) {
      let errorText = `Invalid changes index value (${changesIndex}) versus changes length (${changesLength})`;
      HDLmAssert(false, errorText);
    }
    /* If the changes index points before the first entry in the changes
       array then, we have we have no more changes to undo. Just return 
       to the caller. */
    if (changesIndex < 0) 
      return;
    /* Get the change that can be undone and update the change index */
    let currentChange = HDLmUnRe.changesArray[changesIndex];
    /* Check if the current redo of a change should just be ignored.
       We want to ignore a redo of a change if the change came from
       the 'wrong' event source and if the change is an activation
       or DND. */
    if (source != 'Fancytree on') {
      if (currentChange.changeType == HDLmUnReTypes.activate ||
          currentChange.changeType == HDLmUnReTypes.dnd)
        return;
      if (HDLmGlobals.activeEditorType == HDLmEditorTypes.popup &&
          (currentChange.changeType == HDLmUnReTypes.collapse ||
           currentChange.changeType == HDLmUnReTypes.expand))
        return;
    }
    changesIndex--;
    HDLmUnRe.changesIndex--;
    if (HDLmGlobals.activeDebugging.showStatus)
      HDLmUnRe.showStatus();
    HDLmUnRe.undoExecute(currentChange, source);
  }
  /* This routine does the actual work of undoing a change. The caller
     passes a change object. This routine examines the change object 
     and does all of the work needed to undo the change. */
  static undoExecute(currentChange, source) {
    /* console.log('In HDLmUnRe.undoExecute'); */
    /* console.log('currentChange: ', currentChange); */
    let fancyTreeNode;
    let type = currentChange.changeType;
    switch (type) {
      /* Undo an activation event */
      case HDLmUnReTypes.activate: {
        /* Check if we have a different node that was previously active.
           If this is true, then all we need to do is to activate the 
           previously active node. */
        if (currentChange.oldPath != null) {
          let fancyTreeNode;
          /* We have found cases (valid cases) where the old Fancytree node 
             can not be located. This will always happen if the old Fancytree
             node no longer exists. In these cases, we don't want to generate
             an error message. */
          fancyTreeNode = HDLmTree.locateFancyNode(currentChange.oldPath);
          if (fancyTreeNode == null)
            return;
          /* Try to locate the Fancytree node */
          /* let fancyTreeNode = HDLmTree.locateFancyNode(currentChange.oldPath); */        
          /* Report an error if the Fancytree node could not be found */
          if (fancyTreeNode == null) {
            let nodeString = currentChange.oldPath.toString();
            HDLmError.buildError('Error', 'Locate', 25, nodeString);
            return;
          }
          /* We have some work to do, if we located the Fancytree node */
          if (fancyTreeNode != null) {
            /* 
            if (HDLmGlobals.activeDebugging.ignoreChange)
              console.log(`Undo Execute Activate - Ignore Deactivate Value (${HDLmUnRe.changesIgnoreDeactivate})`); 
            */
            HDLmUnRe.changesIgnoreDeactivate++;
            HDLmUnRe.noChangeActivate(fancyTreeNode);
          }
          break;
        }
        /* It appears that no different node was previously active. As a 
           consequence, we just need to deactivate the currently active
           node. Try to locate the Fancytree node */
        let fancyTreeNode = HDLmTree.locateFancyNode(currentChange.newPath);
        /* Report an error if the Fancytree node could not be found */
        if (fancyTreeNode == null) {
          let nodeString = currentChange.newPath.toString();
          HDLmError.buildError('Error', 'Locate', 25, nodeString);
          return;
        }
        /* We have some work to do, if we located the Fancytree node */
        if (fancyTreeNode != null) {
          HDLmUnRe.noChangeDeactivate(fancyTreeNode);
          break;
        }
      }
      /* Undo a collapse event */
      case HDLmUnReTypes.collapse: {
        /* Try to locate the Fancytree node */
        let fancyTreeNode = HDLmTree.locateFancyNode(currentChange.nodePath);
        /* Report an error if the Fancytree node could not be found */
        if (fancyTreeNode == null) {
          let nodeString = currentChange.nodePath.toString();
          HDLmError.buildError('Error', 'Locate', 25, nodeString);
          return;
        }
        /* Just exit if we did not find the Fancytree node */
        if (fancyTreeNode == null)
          break;
        HDLmUnRe.noChangeExpand(fancyTreeNode);
        break;
      }
      /* Undo a copy event */
      case HDLmUnReTypes.copy: {
        HDLmGlobals.activeCopyBuffer = currentChange.oldCopyValue;
        break;
      }
      /* Undo a cut (ctrl-x) event */
      case HDLmUnReTypes.cut: {
        /* Actually undoing the cut will cause an expand event for the node that
           is being restored. Of course, we don't want add an expand event to the 
           undo / redo changes array. */
        /* 
        if (HDLmGlobals.activeDebugging.ignoreChange)
          console.log(`Undo Execute Cut - Ignore Expand Value (${HDLmUnRe.changesIgnoreExpand})`); 
        */
        HDLmUnRe.changesIgnoreExpand++;
        /* Restore the copy buffer to the prior value */
        HDLmGlobals.activeCopyBuffer = currentChange.oldCopyValue;
        /* Get the cut Fancytree node path and the tree data that must be 
           restored. Note that the path stored in the undo / redo change event
           is of the cut node, not the parent of the cut node. */
        let cutTreePath = currentChange.oldPath.slice();
        let cutTreeNode = JSON.parse(currentChange.newCopyValue);
        let isActive = currentChange.isActive;
        let isExpanded = currentChange.isExpanded;
        /* Try to locate the parent Fancytree node */
        let reportFancyLocateErrors = true;
        let parentFancytreeNode = HDLmTree.locateFancyParentNode(cutTreePath, reportFancyLocateErrors);
        /* Report an error if the Fancytree node could not be found */
        if (parentFancytreeNode == null) {
          let nodeString = parentFancyPath.toString();
          HDLmError.buildError('Error', 'Locate', 25, nodeString);
          return;
        }
        let handlingCmdInsertFalse = false;
        let processSubNodesTrue = true;
        let updateDatabase = true;
        let usePendingInsertsTrue = true;
        HDLmMenus.insertIntoBothTrees(parentFancytreeNode, cutTreeNode, 
                                      usePendingInsertsTrue, processSubNodesTrue, updateDatabase,
                                      handlingCmdInsertFalse);
        HDLmTree.processPendingInserts();
        /* Try to locate the new (was cut) Fancytree node */
        let newFancytreeNode = HDLmTree.locateFancyNode(cutTreePath);
        /* Report an error if the new (was cut) Fancytree node could not be found */
        if (newFancytreeNode == null) {
          let nodeString = cutTreePath.toString();
          HDLmError.buildError('Error', 'Locate', 25, nodeString);
          return;
        }
        HDLmUnRe.resetNode(newFancytreeNode, isActive, isExpanded); 
        break;
      }
      /* Undo a delete event */
      case HDLmUnReTypes.delete: {
        /* Get the parent Fancytree node path and the tree data that must be 
           restored. Note that the path stored in the undo / redo change event
           is of the deleted node, not the parent of the deleted node. */
        let deletedTreePath = currentChange.oldPath.slice();
        let reportFancyLocateErrors = true;
        let parentFancytreeNode = HDLmTree.locateFancyParentNode(deletedTreePath, reportFancyLocateErrors);        
        let deletedTreeNode = JSON.parse(currentChange.oldCopyValue);
        let handlingCmdInsertFalse = false;
        let isActive = currentChange.isActive;
        let isExpanded = currentChange.isExpanded;
        let processSubNodesTrue = true;
        let updateDatabase = true;        
        let usePendingInsertsTrue = true;
        HDLmMenus.insertIntoBothTrees(parentFancytreeNode, deletedTreeNode, 
                                      usePendingInsertsTrue, processSubNodesTrue, updateDatabase,
                                      handlingCmdInsertFalse);
        HDLmTree.processPendingInserts();
        /* Try to locate the new (was deleted) Fancytree node */
        let newFancytreeNode = HDLmTree.locateFancyNode(deletedTreePath);
        /* Report an error if the new (was deleted) Fancytree node could not be found */
        if (newFancytreeNode == null) {
          let nodeString = deletedTreePath.toString();
          HDLmError.buildError('Error', 'Locate', 25, nodeString);
          return;
        }
        HDLmUnRe.resetNode(newFancytreeNode, isActive, isExpanded);
        break;
      }
      /* Undo a DND event */
      case HDLmUnReTypes.dnd: {
        let isActive = currentChange.isActive;
        let isExpanded = currentChange.isExpanded;
        let dndTreeNode = JSON.parse(currentChange.newCopyValue);
        /* Get the path to the child node that must be deleted */
        let childNodePath = currentChange.newPath.slice();
        let reportFancyLocateErrors = true;
        let parentFancytreeNode = HDLmTree.locateFancyParentNode(childNodePath, reportFancyLocateErrors);  
        /* Try to locate the child Fancytree node */
        let childFancytreeNode = HDLmTree.locateFancyNode(childNodePath);
        /* Report an error if the Fancytree node could not be found */
        if (childFancytreeNode == null) {
          let nodeString = childNodePath.toString();
          HDLmError.buildError('Error', 'Locate', 25, nodeString);
          return;
        }
        /* Try to locate the child tree node using the child node path */
        let childTreeNode = HDLmTree.locateTreeNode(childNodePath);
        /* Report an error if the node could not be found */
        if (childTreeNode == null) {
          let nodeString = childNodePath.toString();
          console.log('In HDLmunRe.undoExecute', nodeString);
          HDLmError.buildError('Error', 'Locate', 9, nodeString);
          return;
        }
        /* Locate the from Fancytree node and the from node. Both must be 
           deleted here. */
        let oldFromNodePath = currentChange.oldPath.slice();
        let oldParentFromNodePath = oldFromNodePath.slice(0, oldFromNodePath.length-1);
        /* We need to modify all of the tree node paths so that they contain
           the correct values for where the data is being moved from */
        HDLmTree.modifyTreeNodePath(oldFromNodePath, dndTreeNode);
        /* Try to locate the Fancytree node using the old node path */
        let oldParentFromFancytreeNode = HDLmTree.locateFancyNode(oldParentFromNodePath);
        /* Report an error if the parent Fancytree node could not be found */
        if (oldParentFromFancytreeNode == null) {
          let nodeString = oldParentFromNodePath.toString();
          HDLmError.buildError('Error', 'Locate', 25, nodeString);
          return;
        }
        /* Try to locate the parent from tree node using the old node path */
        let fromParentTreeNode = HDLmTree.locateTreeNode(oldParentFromNodePath);
        /* Report an error if the parent node could not be found */
        if (fromParentTreeNode == null) {
          let nodeString = oldParentFromNodePath.toString();
          console.log('In HDLmunRe.undoExecute', nodeString);
          HDLmError.buildError('Error', 'Locate', 9, nodeString);
          return;
        }
        /* Invoke a standard routine to do all of the actual work of deleting 
           the tree node and the Fancytree node */
        HDLmTree.deleteTreeNode(childFancytreeNode, childTreeNode);
        let handlingCmdInsertFalse = false;
        let processSubNodesTrue = true;
        let updateDatabase = true;
        let usePendingInsertsTrue = true;
        HDLmMenus.insertIntoBothTrees(oldParentFromFancytreeNode, dndTreeNode, 
                                      usePendingInsertsTrue, processSubNodesTrue, updateDatabase,
                                      handlingCmdInsertFalse);
        HDLmTree.processPendingInserts();
        HDLmUnRe.resetNode(parentFancytreeNode, isActive, isExpanded, handlingCmdInsertFalse);
        break;
      }
      /* Undo an edit event */
      case HDLmUnReTypes.edit: {
        /* Get the old node name and the new node name. At this point
           the node will actually have the new node name. */
        let oldName = currentChange.oldName;
        let newName = currentChange.newName;
        let oldPath = currentChange.oldPath.slice();
        let isActive = currentChange.isActive;
        let isExpanded = currentChange.isExpanded;
        /* Build the path for the current node. The path for the node
           must use the new node name. */
        let newPath = oldPath.slice(0, oldPath.length - 1);
        newPath.push(newName);
        /* Try to locate the tree node using the new node path */
        let targetTreeNode = HDLmTree.locateTreeNode(newPath);
        /* Report an error if the tree node could not be found */
        if (targetTreeNode == null) {
          let nodeString = newPath.toString();
          console.log('In HDLmunRe.undoExecute', nodeString);
          HDLmError.buildError('Error', 'Locate', 9, nodeString);
          return;
        }
        /* Try to locate the Fancytree node using the new node path */
        let fancyTreeNode = HDLmTree.locateFancyNode(newPath);
        /* Report an error if the Fancytree node could not be found */
        if (fancyTreeNode == null) {
          let nodeString = newPath.toString();
          HDLmError.buildError('Error', 'Locate', 25, nodeString);
          return;
        }
        /* Create a new Fancytree node by undoing the current change */
        let removeOldFancyTrue = true;
        let newFancyNode = HDLmTree.modifyNodeName(oldName, fancyTreeNode, targetTreeNode, removeOldFancyTrue);
        HDLmUnRe.resetNode(newFancyNode, isActive, isExpanded);
        HDLmTree.updateRelatedOperations(oldPath);
        break;
      }
      /* Undo an expand event */
      case HDLmUnReTypes.expand: {
        /* Try to locate the Fancytree node */
        let fancyTreeNode = HDLmTree.locateFancyNode(currentChange.nodePath);
        /* Report an error if the Fancytree node could not be found */
        if (fancyTreeNode == null) {
          let nodeString = currentChange.nodePath.toString();
          HDLmError.buildError('Error', 'Locate', 25, nodeString);
          return;
        }
        /* Just exit if we did not find the Fancytree node */
        if (fancyTreeNode == null)
          break;
        HDLmUnRe.noChangeCollapse(fancyTreeNode);
        break;
      }
      /* Undo an insert event */
      case HDLmUnReTypes.insert: {
        /* Get the path to the child node that must be deleted */
        let childNodePath = currentChange.newPath.slice();
        /* Try to locate the child Fancytree node */
        let childFancytreeNode = HDLmTree.locateFancyNode(childNodePath);
        /* Report an error if the Fancytree node could not be found */
        if (childFancytreeNode == null) {
          let nodeString = childNodePath.toString();
          HDLmError.buildError('Error', 'Locate', 25, nodeString);
          return;
        }
        /* Try to locate the child tree node using the child node path */
        let childTreeNode = HDLmTree.locateTreeNode(childNodePath);
        /* Report an error if the node could not be found */
        if (childTreeNode == null) {
          let nodeString = childNodePath.toString();
          console.log('In HDLmunRe.undoExecute', nodeString);
          HDLmError.buildError('Error', 'Locate', 9, nodeString);
          return;
        }
        /* Invoke a standard routine to do all of the actual work of deleting 
           the tree node and the Fancytree node */
        HDLmTree.deleteTreeNode(childFancytreeNode, childTreeNode);
        break;
      }
      /* Undo a node modify event */
      case HDLmUnReTypes.modify: {
        /* Get the old node state and the node path */ 
        let oldNodeState = currentChange.oldNodeState;
        let nodePath = currentChange.nodePath.slice();
        /* Try to locate the tree node using the node path */
        let targetTreeNode = HDLmTree.locateTreeNode(nodePath);
        /* Report an error if the tree node could not be found */
        if (targetTreeNode == null) {
          let nodeString = nodePath.toString();
          console.log('In HDLmunRe.undoExecute', nodeString);
          HDLmError.buildError('Error', 'Locate', 9, nodeString);
          return;
        }
        /* This code is not executed for now */
        if (1 == 2) {
          /* 
          if (HDLmGlobals.activeDebugging.ignoreChange)
            console.log(`Undo Execute Modify - Ignore Modify Value (${HDLmUnRe.changesIgnoreModify})`); 
          */
          HDLmUnRe.changesIgnoreModify++;
        }
        /* Use the old node state to reset the node */
        targetTreeNode.details = JSON.parse(oldNodeState);
        let divDescriptions = HDLmDefines.getString('HDLMENTRYDESCRIPTIONS');
        let divValues = HDLmDefines.getString('HDLMENTRYVALUES');
        let callSource = 'HDLmUnRe.redoExecute';
        let currentDomElementNull = null;
        let handlingCmdInsertFalse = false;
        let inlineStartupFlagFalse = false;
        let newTreeEntryTrue = true;
        let possibleRuleTypesNull = null;
        HDLmMod.displayMod(divDescriptions, divValues, targetTreeNode,
                           possibleRuleTypesNull, currentDomElementNull,
                           HDLmGlobals.activeEditorType, newTreeEntryTrue,
                           inlineStartupFlagFalse, handlingCmdInsertFalse,
                           callSource);
        HDLmTree.updateRelatedOperations(nodePath);
        break;
      }
      /* Undo a paste event */
      case HDLmUnReTypes.paste: {
        /* Get the path to the child node that must be deleted */
        let childNodePath = currentChange.newPath.slice();
        /* Try to locate the child Fancytree node */
        let childFancytreeNode = HDLmTree.locateFancyNode(childNodePath);
        /* Report an error if the Fancytree node could not be found */
        if (childFancytreeNode == null) {
          let nodeString = childNodePath.toString();
          HDLmError.buildError('Error', 'Locate', 25, nodeString);
          return;
        }
        /* Try to locate the child tree node using the child node path */
        let childTreeNode = HDLmTree.locateTreeNode(childNodePath);
        /* Report an error if the node could not be found */
        if (childTreeNode == null) {
          let nodeString = childNodePath.toString();
          console.log('In HDLmunRe.undoExecute', nodeString);
          HDLmError.buildError('Error', 'Locate', 9, nodeString);
          return;
        }  
        /* Invoke a standard routine to do all of the actual work of deleting 
           the tree node and the Fancytree node */
        HDLmTree.deleteTreeNode(childFancytreeNode, childTreeNode);
        break;
      }
      /* Report an error if the undo / redo change type did not match one 
         of the expected choices */
      default: {
        let errorString = type;
        HDLmError.buildError('Error', 'Invalid type', 24, errorString);
        break;
      }
    }
  }
}
/* The next global value is used to keep track of the changes subject
   to undo/redo processing. Of course, this array starts out empty. 
   Each entry in this array has all of the information needed to remove
   and/or restore a change. The maximum size of this array is fixed. 
   Once the array is full, new entries will cause old entries to be
   removed from the array. */
HDLmUnRe.changesArray = [];
/* The next global value is used to keep track of the current entry
   in the changes array. The current entry is generally the last entry
   added to the changes array. However, the index can be a very different
   value if undo/redo processing is underway. */
HDLmUnRe.changesIndex = -1;
/* The next set of global values are used to force certain events to be 
   ignored. The process of redoing and/or undoing an event can cause other 
   events to occur. We don't really want to add these (generated) events
   to be added to the events (changes) array. These values are used to force
   certain events to be ignored. */
HDLmUnRe.changesIgnoreActivate = 0;
/* Note that the check event type is not in use at this time. It turns
   output that using the context menus to change the enablement status
   of a modification causes a very conventional keyboard operation to
   be simulated.The keyboard operation can be undone and redone as need be. */
HDLmUnRe.changesIgnoreCheck = 0; 
HDLmUnRe.changesIgnoreCollapse = 0; 
HDLmUnRe.changesIgnoreCopy = 0; 
HDLmUnRe.changesIgnoreCut = 0; 
HDLmUnRe.changesIgnoreDeactivate = 0;
HDLmUnRe.changesIgnoreDelete = 0;
HDLmUnRe.changesIgnoreDnd = 0;
HDLmUnRe.changesIgnoreEdit = 0;
HDLmUnRe.changesIgnoreExpand = 0; 
HDLmUnRe.changesIgnoreForce = 0; 
HDLmUnRe.changesIgnoreInsert = 0; 
HDLmUnRe.changesIgnoreModify = 0; 
HDLmUnRe.changesIgnorePaste = 0; 
/* The next global value is used to keep track of the last active node.
   This field is set each time a deactivate event occurs. In other words,
   the path of the node being deactivated is stored in the field below.
   Yes, this is an ugly mess. However, no better method of keeping track
   of the previously active node has been found. 

   The underlying logic here is that when a node is activated, the previously
   active node (if any) is deactivated. The path associated with the node 
   being deactivated can be captured and stored in the field below. */
HDLmUnRe.changesLastActiveNodePath = null;
/* The HDLmUnReChange class is used to keep track of changes (events) that
   can be undone / redone. Each instance of this class represents one event
   that can be undone / redone. Each instance of this class must contain all 
   of the infomation needed to undo / redo a change. */
class HDLmUnReChange {
  /* Build a undo / redo event instance. The caller provides the event 
     type. The caller add all of the additional data needed to undo and/or
     redo a change. */ 
  constructor(changeType) {
    this.changeType = HDLmUnReTypes.none;
    this.oldName = null;
    this.newName = null;
    /* Note that the old copy value and new copy value are always
       JSON strings. These JSON strings may have to be converted 
       back to objects before they can be used. 
       
       Note that these value are also used for cut (ctrl-x) operations.  
       A successful cut (ctrl-x) operation will save the old copy buffer
       and then update the copy buffer with the cut (ctrl-x) data. */
    this.oldCopyValue = null;
    this.newCopyValue = null;
    this.oldNodeState = null;
    this.newNodeState = null;
    this.oldPath = null;
    this.newPath = null;
    this.isActive = null;
    this.isChecked = null;
    this.isExpanded = null;
    this.changeType = changeType;
  }
}